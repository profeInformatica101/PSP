<!doctype html>
<html lang="es" data-bs-theme="light">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RA1 · Process & ProcessBuilder · Laboratorio interactivo</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{background:#f8fafc}
    code{color:purple}
    code,kbd,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
    pre{background:#0f172a;color:#e2e8f0;border-radius:.75rem;padding:1rem;overflow:auto}
    .small-muted{font-size:.92rem;color:#64748b}
    .card{border-radius:1rem}
  </style>
</head>
<body>
<div class="container my-4">
  <section class="mb-4">
    <h2 class="h5 mb-2">RA1 · Process / ProcessBuilder (Carrusel 0–11)</h2>
    <p class="small-muted mb-3">
      Objetivo: desarrollar aplicaciones con varios procesos aplicando principios de concurrencia y paralelismo.
      Cada ejercicio explica métodos Java, comandos del SO y el criterio RA1 al que contribuye.
    </p>
<p class="small-muted mb-3">
  <mark>Repositorio en GitHub: <code>psp_java</code></mark>
<div class="small-muted">
  <p class="mb-2"><strong>Organización correcta del proyecto</strong></p>
<pre class="mb-2"><code>psp_java/
 ├── src/
 │   └── psp/                # Paquete con todas las clases de los ejercicios
 │       ├── Utils.java
 │       ├── Ej1_Basico.java
 │       ├── Ej2_LeerSalida.java
 │       └── ...
 ├── doc/                    # Apuntes, diagramas, capturas
 ├── .gitignore              # (opcional) bin/, .classpath, .project, .settings/
 └── README.md               # Instrucciones de uso (compilar/ejecutar)</code></pre>


</p>

<div class="small-muted">
  <p><strong>Pasos básicos:</strong></p>
  <ol>
    <li>En GitHub, crear un repositorio vacío con el nombre <code>psp_java</code>.</li>
    <li>En Eclipse, crear un proyecto Java con el nombre <code>PSP_UD1</code>.</li>
    <li>Añadir el paquete <code>psp</code> dentro de <code>src/</code> y programar ahí las clases de los ejercicios.</li>
    <li>Subir el contenido del proyecto <code>PSP_UD1</code> al repositorio <code>psp_java</code> de GitHub.</li>
  </ol>
</div>

   <video
                class="w-100 h-100"
                controls
                preload="metadata"
                playsinline
              
              >
                <source src="../../ud1/video/Gestión_de_Procesos_en_Java.mp4" type="video/mp4">
               
              </video>

    <div id="ejCarousel" class="carousel slide" data-bs-ride="false" data-bs-touch="true">
      <!-- Indicadores -->
      <div class="carousel-indicators">
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="0" class="active" aria-current="true" aria-label="Ej 0"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="1" aria-label="Ej 1"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="2" aria-label="Ej 2"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="3" aria-label="Ej 3"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="4" aria-label="Ej 4"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="5" aria-label="Ej 5"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="6" aria-label="Ej 6"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="7" aria-label="Ej 7"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="8" aria-label="Ej 8"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="9" aria-label="Ej 9"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="10" aria-label="Ej 10"></button>
        <button type="button" data-bs-target="#ejCarousel" data-bs-slide-to="11" aria-label="Ej 11"></button>
      </div>

      <div class="carousel-inner">

        <!-- ========== Slide 0: Utils ========== -->
        <div class="carousel-item active">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">0) Utilidades y portabilidad de comandos</h3>
              <p class="small-muted">Base común para todos los ejercicios (portabilidad Linux/Windows).</p>
<pre><code>// Utils.java
import java.util.*;
public class Utils {
  public static boolean isWindows() {
    return System.getProperty("os.name").toLowerCase().contains("win");
  }
  public static List&lt;String&gt; sh(String cmd) {
    return isWindows() ? Arrays.asList("cmd","/c",cmd)
                       : Arrays.asList("sh","-c",cmd);
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Comunicación entre procesos; gestión multiplataforma.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 1: start/waitFor/exitValue ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">1) Ciclo básico: start · waitFor · exitValue</h3>
              <p><strong>Métodos Java:</strong></p>
              <ul class="small-muted">
                <li><code>new ProcessBuilder(List&lt;String&gt;)</code>: define comando.</li>
                <li><code>start()</code>: lanza el subproceso.</li>
                <li><code>waitFor()</code>: bloquea hasta finalizar y devuelve RC.</li>
                <li><code>exitValue()</code>: código de salida (0 OK, ≠0 error).</li>
              </ul>
              <p><strong>Comandos SO:</strong> <code>echo hola</code> (Linux) · <code>cmd /c echo hola</code> (Win)</p>
<pre><code>// Ej1_Basico.java
import java.util.*;
public class Ej1_Basico {
  public static void main(String[] args) throws Exception {
    Process p = new ProcessBuilder(Utils.sh("echo hola")).start();
    int rc = p.waitFor();
    System.out.println("RC=" + rc);
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Características de procesos y su ejecución por el SO.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 2: Streams E/S ========== -->
<!-- ========== Slide 2: Streams E/S ========== -->
<div class="carousel-item">
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h3 class="h6 mb-2">2) E/S de procesos: STDOUT y STDERR</h3>
      <p><strong>Métodos Java:</strong></p>
      <ul class="small-muted">
        <li><code>getInputStream()</code>: lee STDOUT.</li>
        <li><code>getErrorStream()</code>: lee STDERR.</li>
        <li><code>BufferedReader</code>: lectura línea a línea (requiere cierre manual con <code>close()</code>).</li>
      </ul>
      <p><strong>Comandos SO:</strong> <code>java -version</code> (suele ir a STDERR), <code>echo hola</code> (STDOUT)</p>
<pre><code>// Ej2_LeerSalida.java
import java.io.*; 
import java.util.*;

public class Ej2_LeerSalida {
  public static void main(String[] args) {
    // Para convertir bytes en texto:
    // - InputStreamReader → convierte bytes a caracteres.
    // - BufferedReader → permite leer líneas completas y cerrar el recurso.

    try {
      BufferedReader br;

      // ==== PRIMER PROCESO: echo hola ====
      Process p1 = new ProcessBuilder(Utils.sh("echo hola")).start();
      br = new BufferedReader(new InputStreamReader(p1.getInputStream()));
      System.out.println("STDOUT: " + br.readLine());
      br.close();
      p1.waitFor();

      // ==== SEGUNDO PROCESO: java -version (va a STDERR) ====
      Process p2 = new ProcessBuilder(Utils.sh("java -version")).start();
      br = new BufferedReader(new InputStreamReader(p2.getErrorStream()));
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }
      br.close();
      p2.waitFor();

    } catch (IOException e) {
      // Error de entrada/salida: no se pudo leer la salida del proceso
      System.err.println("Error de E/S: " + e.getMessage());
    } catch (InterruptedException e) {
      // Otro hilo interrumpió la espera del proceso
      System.err.println("El proceso fue interrumpido");
    }
  }
}
</code></pre>
      <p class="small-muted mb-0"><strong>RA1:</strong> Comunicación entre procesos (canales E/S).</p>
    </div>
  </div>
</div>

        <!-- ========== Slide 3: redirectErrorStream / inheritIO / Redirect a fichero ========== -->
     <!-- ========== Slide 3: redirectErrorStream / inheritIO / Redirect a fichero ========== -->
<div class="carousel-item">
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h3 class="h6 mb-2">3) Redirecciones: unir flujos y enviar a fichero</h3>
      <p><strong>Métodos Java:</strong></p>
      <ul class="small-muted">
        <li><code>redirectErrorStream(true)</code>: STDERR → STDOUT.</li>
        <li><code>redirectOutput(File)</code>: sobrescribe (como <code>&gt;</code>).</li>
        <li><code>Redirect.appendTo(File)</code>: añade al final (como <code>&gt;&gt;</code>).</li>
        <li><code>redirectError(File)</code>: solo STDERR a fichero.</li>
        <li><code>inheritIO()</code>: hereda consola actual (útil para depurar).</li>
      </ul>
<pre><code>// Ej3_Redir.java
import java.io.*; import java.util.*;
public class Ej3_Redir {
  public static void main(String[] args) throws Exception {
    File out = new File("salida.txt"), err = new File("errores.txt");

    // PROCESO A: une STDOUT+STDERR en un solo fichero (sobrescribe)
    ProcessBuilder a = new ProcessBuilder(Utils.sh("java -version"));
    a.redirectErrorStream(true).redirectOutput(out).start().waitFor();

    // PROCESO B: STDOUT → salida.txt (añadiendo, no sobrescribiendo)
    //            STDERR → errores.txt
    ProcessBuilder b = new ProcessBuilder(Utils.sh(Utils.isWindows()? "dir" : "ls -la"));
    b.redirectOutput(ProcessBuilder.Redirect.appendTo(out))
     .redirectError(err).start().waitFor();

    // PROCESO C: muestra la salida directamente en la misma consola de Java
    new ProcessBuilder(Utils.sh("echo depurando con inheritIO"))
      .inheritIO().start().waitFor();
  }
}</code></pre>
      <p class="small-muted mb-0"><strong>RA1:</strong> Depuración y documentación de aplicaciones (trazabilidad de procesos y salidas).</p>
    </div>
  </div>
</div>
     <!-- ========== Slide 4: directory & environment (contexto) ========== -->
<div class="carousel-item">
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h3 class="h6 mb-2">4) Contexto: directorio de trabajo y variables de entorno</h3>

      <p class="small-muted mb-2">
        <strong>Idea clave:</strong> con <code>ProcessBuilder</code> configuramos el <em>contexto</em> del subproceso
        (directorio de trabajo y variables de entorno). Luego, al llamar a <code>start()</code>, obtenemos un
        <code>Process</code> con el que interactuamos (leer salidas, esperar, destruir, etc.).
      </p>

      <p><strong>Métodos Java:</strong></p>
      <ul class="small-muted">
        <li><code>directory(File)</code>: establece el directorio de inicio del subproceso.</li>
        <li><code>environment()</code>: mapa mutable de variables para el subproceso (no afecta a tu terminal).</li>
        <li><code>inheritIO()</code>: el subproceso escribe en la misma consola que Java (útil para depurar).</li>
      </ul>

<pre><code>// Ej4_Contexto.java (actualizado)
import java.io.*;

public class Ej4_Contexto {
  public static void main(String [] args) throws Exception {
    // Comando para listar todas las variables de entorno
    String cmd = Utils.isWindows() ? "set" : "printenv";
    ProcessBuilder pb = new ProcessBuilder(Utils.sh(cmd));

    // 1) Directorio de trabajo (donde "nace" el subproceso)
    pb.directory(new File(".")); // aquí el actual, pero puedes cambiarlo a otra ruta

    // 2) Variables de entorno SOLO para el subproceso (no para tu sesión)
    pb.environment().put("APP_ENV", "dev");
    pb.environment().put("APP_MODE", "testing");

    // 3) Mostramos la salida directamente en la consola de Java
    pb.inheritIO().start().waitFor();
  }
}
</code></pre>

      <div class="small-muted">
        <p class="mb-1"><strong>ProcessBuilder vs Process (en una frase):</strong></p>
        <ul class="mb-2">
          <li><strong>ProcessBuilder</strong>: el <em>constructor/fábrica</em> y configurador del proceso (comando, <em>working dir</em>, <em>environment</em>, redirecciones).</li>
          <li><strong>Process</strong>: el <em>proceso vivo</em> ya ejecutándose (leer <code>STDOUT/ERR</code>, escribir <code>STDIN</code>, <code>waitFor()</code>, <code>destroy()</code>...).</li>
        </ul>
        <p class="mb-0">
          <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ProcessBuilder.html" target="_blank" rel="noopener">API ProcessBuilder</a> ·
          <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Process.html" target="_blank" rel="noopener">API Process</a>
        </p>
      </div>

      <div class="small-muted mt-2">
        <p class="mb-1"><strong>Notas rápidas para el alumnado:</strong></p>
        <ul class="mb-0">
          <li><em>Directorio de trabajo</em>: afecta a comandos con rutas relativas (p. ej., un <code>ls</code> listará esa carpeta).</li>
          <li><em>Variables de entorno</em>: viven solo en el subproceso (no “contaminan” tu shell). Útiles para parametrizar ejecución (<em>dev</em>, <em>testing</em>, <em>prod</em>...).</li>
        </ul>
      </div>

      <p class="small-muted mb-0"><strong>RA1:</strong> Gestión de procesos en distintos entornos (contexto de ejecución).</p>
    </div>
  </div>
</div>

  <!-- ========== Slide 5: STDIN (IPC simple con entrada de usuario) ========== -->
<div class="carousel-item">
  <div class="card border-0 shadow-sm">
    <div class="card-body">
      <h3 class="h6 mb-2">5) Envío por STDIN (IPC simple) → <code>sort</code> con entrada de teclado</h3>

      <p class="small-muted mb-2">
        <strong>Idea clave:</strong> nuestro programa Java escribe líneas al <em>STDIN</em> del proceso <code>sort</code>,
        y después lee el resultado ya ordenado desde su <em>STDOUT</em>. Aquí añadimos también una fruta introducida por el usuario.
      </p>

      <p><strong>Métodos Java:</strong></p>
      <ul class="small-muted">
        <li><code>getOutputStream()</code>: canal para escribir al proceso hijo (su STDIN) → usamos <code>BufferedWriter</code>.</li>
        <li><code>getInputStream()</code>: canal para leer del proceso hijo (su STDOUT) → usamos <code>BufferedReader</code>.</li>
        <li><code>waitFor()</code>: sincroniza hasta que el proceso termine.</li>
      </ul>

      <p class="small-muted mb-2"><strong>Comando SO:</strong> <code>sort</code> (disponible en Linux y Windows).</p>

<pre><code>// Ej5_Stdin.java (con entrada por teclado)
package psp;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Scanner;

public class Ej5_Stdin {

    public static void main(String[] args) throws Exception {
        // 1) Preparamos lectura por teclado (consola)
        Scanner sc = new Scanner(System.in);

        // 2) Lanzamos el proceso "sort" (ordenará las líneas de texto que reciba por STDIN)
        Process p = new ProcessBuilder(Utils.sh("sort")).start();

        try {
            // 3) Pedimos un dato al usuario para integrarlo en la lista
            System.out.print("Escribe una fruta: ");
            String fruta = sc.nextLine();

            // 4) ENVIAR datos al proceso (STDIN):
            //    - Escribimos varias frutas + la fruta introducida por el usuario.
            //    - Cerramos el Writer para indicar "fin de datos" al proceso sort.
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(p.getOutputStream()));
            bw.write("pera\nmanzana\nuva\n" + fruta + "\n");
            bw.close(); // &lt;-- importante para que sort empiece a procesar

            // 5) LEER el resultado ordenado del proceso (STDOUT):
            //    - Consumimos línea a línea hasta que no haya más datos.
            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String line;
            System.out.println("\nListado ordenado:");
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
            br.close();

            // 6) Sincronizamos: esperamos a que el proceso termine
            p.waitFor();

        } catch (Exception e) {
            // Captura genérica para simplificar en esta práctica
            System.err.println("Ocurrió un error: " + e.getMessage());
        } finally {
            // 7) Buenas prácticas: cerrar recursos creados por nosotros
            sc.close();
        }
    }
}
</code></pre>

      <div class="small-muted">
        <p class="mb-1"><strong>Notas rápidas para el alumnado:</strong></p>
        <ul class="mb-0">
          <li><em>Si no cierras</em> el <code>BufferedWriter</code>, <code>sort</code> se queda esperando más datos y no devuelve nada.</li>
          <li><em>STDIN</em> del proceso hijo ⇢ lo obtenemos con <code>p.getOutputStream()</code> (desde Java “es salida”, hacia el hijo es “entrada”).</li>
          <li><em>STDOUT</em> del proceso hijo ⇢ lo leemos con <code>p.getInputStream()</code>.</li>
        </ul>
      </div>

      <p class="small-muted mb-0"><strong>RA1:</strong> Comunicación entre procesos; sincronización por fin de stream (cierre de STDIN).</p>
    </div>
  </div>
</div>
        <!-- ========== Slide 6: Pipe manual entre procesos ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">6) Encadenado (pipe manual): productor → consumidor</h3>
              <p><strong>Métodos Java:</strong> conectar <code>getInputStream()</code> del 1º con <code>getOutputStream()</code> del 2º.</p>
              <p><strong>Comandos SO:</strong> <code>printf</code> / <code>echo</code> → <code>sort</code></p>
<pre><code>// Ej6_PipeManual.java
import java.io.*; import java.util.*;
public class Ej6_PipeManual {
  public static void main(String[] args) throws Exception {
    String echoCmd = Utils.isWindows()? "(echo a&amp;echo c&amp;echo b)" : "printf \"a\nc\nb\n\"";
    Process p1 = new ProcessBuilder(Utils.sh(echoCmd)).start();
    Process p2 = new ProcessBuilder(Utils.sh("sort")).start();
    try (InputStream in = p1.getInputStream(); OutputStream out = p2.getOutputStream()) {
      in.transferTo(out); // canaliza
    }
    p1.waitFor();
    try (BufferedReader br = new BufferedReader(new InputStreamReader(p2.getInputStream()))) {
      String line; while ((line = br.readLine()) != null) System.out.println(line);
    }
    p2.waitFor();
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Programación multiproceso; patrón pipeline.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 7: timeouts y lifecycle ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">7) Lifecycle: timeout, <code>isAlive</code>, <code>destroy</code></h3>
              <p><strong>Métodos Java:</strong></p>
              <ul class="small-muted">
                <li><code>waitFor(long, TimeUnit)</code>: timeout.</li>
                <li><code>isAlive()</code>: sigue ejecutándose.</li>
                <li><code>destroy()</code> / <code>destroyForcibly()</code>: termina el proceso.</li>
              </ul>
              <p><strong>Comandos SO:</strong> <code>ping -c 5 1.1.1.1</code> (Linux) · <code>ping -n 5 1.1.1.1</code> (Win)</p>
<pre><code>// Ej7_Timeout.java
import java.util.*; import java.util.concurrent.*;
public class Ej7_Timeout {
  public static void main(String[] args) throws Exception {
    String ping = Utils.isWindows()? "ping -n 5 1.1.1.1" : "ping -c 5 1.1.1.1";
    Process p = new ProcessBuilder(Utils.sh(ping)).start();
    if (!p.waitFor(2, TimeUnit.SECONDS)) {
      System.out.println("Timeout: destroy()");
      p.destroy();
      if (p.isAlive()) { System.out.println("Forzando..."); p.destroyForcibly(); }
    }
    System.out.println("Fin. isAlive=" + p.isAlive());
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Gestión de procesos; robustez ante bloqueos.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 8: ProcessHandle + onExit (inspección/async) ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">8) Inspección y callback: <code>ProcessHandle</code> + <code>onExit()</code></h3>
              <p><strong>Métodos Java:</strong></p>
              <ul class="small-muted">
                <li><code>p.pid()</code>, <code>p.info()</code> (<em>command, args, startInstant</em>).</li>
                <li><code>onExit()</code> → <code>CompletableFuture&lt;Process&gt;</code> (no bloqueante).</li>
              </ul>
<pre><code>// Ej8_InfoOnExit.java
import java.util.*; import java.time.*;
public class Ej8_InfoOnExit {
  public static void main(String[] args) throws Exception {
    Process p = new ProcessBuilder(Utils.sh(Utils.isWindows()? "timeout /t 2 &gt;nul" : "sleep 2")).start();
    System.out.println("PID=" + p.pid());
    p.info().command().ifPresent(c -&gt; System.out.println("cmd=" + c));
    p.onExit().thenAccept(proc -&gt; System.out.println("RC=" + proc.exitValue()));
    p.waitFor();
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Concurrencia (callbacks), monitorización de procesos.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 9: Paralelismo real: lanzar N procesos en paralelo ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">9) Paralelismo: ejecutar múltiples procesos y sincronizar resultados</h3>
              <p><strong>Métodos Java:</strong> <code>ExecutorService</code>, <code>Callable</code>, <code>Future.get()</code>, <code>waitFor()</code></p>
              <p><strong>Comando SO (ejemplo):</strong> <code>echo tarea-i</code> (sustituye por tu CLI real)</p>
<pre><code>// Ej9_Paralelo.java
import java.util.*; import java.util.concurrent.*; import java.io.*;
public class Ej9_Paralelo {
  public static void main(String[] args) throws Exception {
    ExecutorService pool = Executors.newFixedThreadPool(4);
    List&lt;Callable&lt;Integer&gt;&gt; tareas = new ArrayList&lt;&gt;();
    for (int i=1; i&lt;=6; i++) {
      final int id = i;
      tareas.add(() -&gt; {
        Process p = new ProcessBuilder(Utils.sh("echo tarea-" + id)).start();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
          System.out.println("OUT[" + id + "]: " + br.readLine());
        }
        return p.waitFor(); // sincroniza y devuelve RC
      });
    }
    List&lt;Future&lt;Integer&gt;&gt; r = pool.invokeAll(tareas);
    pool.shutdown();
    System.out.println("RCs: " + r.stream().map(f -&gt; {
      try { return String.valueOf(f.get()); } catch(Exception e){ return "ERR"; }
    }).toList());
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Programación paralela; sincronización y recogida de resultados.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 10: Monitorización SO (ps/pgrep/top/kill | tasklist/taskkill) ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">10) Monitorización de procesos desde Java</h3>
              <p><strong>Métodos Java:</strong> lectura de salida, composición de comandos portables.</p>
              <p><strong>Comandos SO:</strong></p>
              <ul class="small-muted">
                <li>Linux: <code>ps aux</code>, <code>pgrep -f PATRON</code>, <code>top -b -n 1 | head -n 5</code>, <code>kill PID</code>.</li>
                <li>Windows: <code>tasklist</code>, <code>findstr /i PATRON</code>, <code>taskkill /PID PID /F</code>.</li>
              </ul>
<pre><code>// Ej10_Monitor.java
import java.io.*; import java.util.*;
public class Ej10_Monitor {
  static void run(String cmd) throws Exception {
    Process p = new ProcessBuilder(Utils.sh(cmd)).start();
    try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
      String line; while ((line=br.readLine())!=null) System.out.println(line);
    }
    p.waitFor();
  }
  public static void main(String[] args) throws Exception {
    if (Utils.isWindows()) {
      run("tasklist | findstr /i java");
    } else {
      run("ps aux | grep -i java | grep -v grep");
      run("top -b -n 1 | head -n 5");
    }
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Herramientas de monitorización y gestión de procesos.</p>
            </div>
          </div>
        </div>

        <!-- ========== Slide 11: Servicios (systemctl/service/sc) ========== -->
        <div class="carousel-item">
          <div class="card border-0 shadow-sm">
            <div class="card-body">
              <h3 class="h6 mb-2">11) Servicios del sistema (arranque/estado)</h3>
              <p><strong>Métodos Java:</strong> <code>ProcessBuilder</code> + lectura de salida; manejo de códigos de retorno.</p>
              <p><strong>Comandos SO:</strong></p>
              <ul class="small-muted">
                <li>Linux (systemd): <code>systemctl status|start|stop nombre</code>; fallback: <code>service nombre status</code>.</li>
                <li>Windows: <code>sc query "Nombre"</code>, <code>sc start|stop "Nombre"</code>.</li>
              </ul>
<pre><code>// Ej11_Servicios.java
import java.io.*; import java.util.*;
public class Ej11_Servicios {
  static void print(Process p) throws Exception {
    try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
      String s; while((s=br.readLine())!=null) System.out.println(s);
    }
    p.waitFor();
  }
  public static void main(String[] args) throws Exception {
    String nombre = (args.length&gt;0? args[0] : (Utils.isWindows()? "Dnscache" : "cron"));
    if (Utils.isWindows()) {
      print(new ProcessBuilder(Utils.sh("sc query \"" + nombre + "\"")).start());
    } else {
      Process p = new ProcessBuilder(Utils.sh("systemctl status " + nombre)).start();
      int rc = p.waitFor();
      if (rc!=0) { System.out.println("(fallback) service"); print(new ProcessBuilder(Utils.sh("service " + nombre + " status")).start()); }
      else { print(new ProcessBuilder(Utils.sh("systemctl status " + nombre)).start()); }
    }
  }
}</code></pre>
              <p class="small-muted mb-0"><strong>RA1:</strong> Ejecutables/Procesos/Servicios; gestión operativa.</p>
            </div>
          </div>
        </div>

      </div>

      <!-- Controles -->
      <button class="carousel-control-prev" type="button" data-bs-target="#ejCarousel" data-bs-slide="prev">
        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
        <span class="visually-hidden">Anterior</span>
      </button>
      <button class="carousel-control-next" type="button" data-bs-target="#ejCarousel" data-bs-slide="next">
        <span class="carousel-control-next-icon" aria-hidden="true"></span>
        <span class="visually-hidden">Siguiente</span>
      </button>
    </div>
  </section>

  <!-- Mini-mapa RA1 -->
  <section class="mb-4">
    <h3 class="h6">Mapa rápido RA1 ↔ ejercicios</h3>
    <ul class="small-muted">
      <li><strong>Procesos y ejecución por el SO:</strong> 1, 3, 4, 7.</li>
      <li><strong>Concurrencia/Callbacks:</strong> 8 (<code>onExit</code>).</li>
      <li><strong>Paralelismo y sincronización:</strong> 9 (<code>ExecutorService</code>, <code>Future.get()</code>).</li>
      <li><strong>Comunicación entre procesos (IPC):</strong> 2, 5, 6.</li>
      <li><strong>Monitorización/gestión:</strong> 10 (ps/top/pgrep/kill), 11 (servicios).</li>
      <li><strong>Depuración/documentación:</strong> 3 (redirecciones, <code>inheritIO</code>).</li>
    </ul>
  </section>
  
</div>

<!-- Bootstrap Bundle JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
</body>
</html>
